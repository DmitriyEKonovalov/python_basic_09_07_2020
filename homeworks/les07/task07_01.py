"""
1.
Реализовать класс Matrix (матрица).
Обеспечить перегрузку конструктора класса (метод __init__() ),
который должен принимать данные (список списков) для формирования матрицы.
Подсказка: матрица — система некоторых математических величин, расположенных в виде
прямоугольной схемы. Примеры матриц:
- 3 на 2        - 3 на 3            - 2 на 4
31  22          3   5   32          3   5   8   3
37  43          2   4   6           8   3   7   1
51  86          -1  64  -8

Следующий шаг — реализовать перегрузку метода __str__() для вывода матрицы в привычном виде.
Далее реализовать перегрузку метода __add__() для операции сложения двух объектов класса Matrix (двух матриц).
Результатом сложения должна быть новая матрица.
Подсказка: сложение элементов матриц выполнять поэлементно — первый элемент первой
строки первой матрицы складываем с первым элементом первой строки второй матрицы и т.д.
"""


class Matrix:

    def __init__(self, data):
        self.data = data

    def __str__(self):
        result = ''.join(['\t'.join([str(item) for item in lst] + ['\n']) for lst in self.data])
        return result[:]

    def __len__(self):
        return len(list(self.data))

    def __add__(self, another):
        """
        Функция поэлементного сложения матриц.
        Немного усложнил алгоритм, чтобы работало с матрицами разной размерности,
        в том числе с разной размерностью строк внутри матриц.
        Результат функции - матрица, с суммой элементов обеих матриц с одинаковыми индексами,
        ширина равна самой широкой строке и высота равна самому большому кол-ву строк взятых из обеих матриц.
        Недостающие элементы заменяются на нули.
        :param b:
        :return:
        """

        def sum_lists_val(lst_a, lst_b, lst_len=0) -> list:
            """
            Локальная функция для попарного сложения элементов списка lst_a и lst_b.
            В случае разной длины списков, отсутствующие элементы заменяются на 0.
            Если длина результирующего списка меньше to_len, то результат заполняется 0 до длины to_len
            """
            min_lst = min((lst_a, lst_b))
            max_lst = max((lst_a, lst_b))
            result_lst = list(map(sum, zip(lst_a, lst_b)))
            result_lst.extend((max_lst[len(min_lst):]))
            if len(result_lst) < lst_len:
                result_lst += [0] * (lst_len - len(result_lst))
            return result_lst

        # присваиваю аргументы временным переменным, чтобы работать с короткими именами и в виде списков
        a = self.data
        b = another.data
        # предварительные вычисления
        min_matrix = a if len(a) < len(b) else b  # матрица минимальной высоты
        max_matrix = a if len(a) > len(b) else b  # матрица максимальной высоты
        max_row_w = max(max([len(row) for row in a]), max([len(row) for row in b]))  # размер самой длинной строки

        # строки (списки) обеих матриц, складываются поэлементно с приведением длине самой широкой строки
        result = [sum_lists_val(a_row, b_row, max_row_w) for a_row, b_row in zip(a, b)]

        # добавляются оставшиеся строки большей матрицы с одновременным приведением к длине самой широкой строки
        result += [sum_lists_val(row, [], max_row_w) for row in max_matrix[len(min_matrix):]]
        return Matrix(result)

    @property
    def matrix(self):
        return self.data

    @matrix.setter
    def matrix(self, items):
        self.data = items


# примеры использования
x = Matrix([[1, 2], [3, 4], [5, 6, 13, 14, 15]])
print(x)

y = Matrix([[7, 8, 9], [10, 11, 12]])
print(y)

z = x + y
print(z)

